# OGC API - Environmental Data Retrieval (EDR) 
 The EDR implementation has a modular structure in order to enable seamless integration of different data backend types. This implementation has the capability to perform data queries on NetCDF files. The EDR server application supports the position, radius and area data query endpoints of the EDR standard.

## Core Architecture
- *controller:* Controller classes accept API requests, choose the correct backend to handle a request and return the result to the client. The controller classes (empty stubs) are generated by the OpenAPI code generator along with the model classes. 
- *request transformer:* A request transformer is specific to the backend type. A Request transformer converts a request to the EDR API into a corresponding request to the specific data backend. A request transformers delegates the execution of data query requests to a data query transformer.
- *data query transformer:* A query transformer is a backend specific implementation that executes data query request for data served by a data backend.
- *format transformer:* A format transfomer is optionally interposed if a data backend has no support for the netCDF format. Since the EDR implementation only serves netCDF files and has only a netCDF backend there are no format transformers used. 
- *backend:* A backend stores the configuration for a instance of a backend type (e.g location of a netCDF file) and determines which type of request transformer has to be used for the specific backend type

![architecture overview](https://raw.githubusercontent.com/opengeospatial/T17-API-D165/main/resources/diagrams/d165_api_edr_architecture.png "schematic representation of the architecture of the OGC API - EDR implementation with a single data backend")
## Data Backends

### NetCDF backend
The NetCDF backend parses NetCDF files. Each file corresponds to an instance of a collection. The backend is adapted to the use of NetCDF land cover classification data provided by the [D168 Data Backend and Deployment task](https://github.com/opengeospatial/T17-API-D168) of the API Experiments thread of OGC Testbed 17. The general assumptions about the internal structure of these files is that each file contains a single data array, which has the dimensions _x_, _y_ and _time_.

To implement data queries the NetCDF backend implementation mainly uses the Python packages [Rasterio](https://rasterio.readthedocs.io/en/latest/), [xarray](http://xarray.pydata.org/en/stable/) and [Shapely](https://shapely.readthedocs.io/en/stable/manual.html). In addition, a package called [rioxarray](https://corteva.github.io/rioxarray/stable/readme.html) is used. Rasterio is used to clip raster data to a specific geometry and xarray is used to implement filter capabilities like the optional datetime filter. The internal data structure of xarray resembles the structure of a NetCDF file. rioxarray combines the functionalities of Rasterio and xarray which supports convenient use without transformation between (internal) data formats. Shapely is used to parse WKT geometries that are passed to the data query endpoints as query parameters.

## Deployment
This section contains information on how to deploy the python server implementation.

### Run locally
The application can be started locally using the build-in Flask webserver. This is not meant for use in a production environment and should only be used for development and debugging. Before running the application all required python packages must be installed (defined in *requirements.txt*). Using a virtual python environment (like VENV) is helpful for managing the required packages. Additionaly this EDR implementation requires [GDAL](https://gdal.org/) and GDAL python bindings.   
Start the the application with the following command:  
`python -m openapi_server.main.py`
### Run with Docker
The easiest way to deploy and run the application is using Docker. The dockerfile is structured in such a way that all required dependencies (python packages and GDAL) are defined in it. It is also structured as a multistage build comprising targets for production deployment and debugging.
For production deplyoment use the following command to build the docker image:  
`docker build -t tb17_apiexperiments_edrserver_python --target prod .`  
The resulting image uses production-ready webserver.  
For debugging purposes use the following command to build the docker image:  
`docker build -t tb17_apiexperiments_edrserver_python --target debug .`  
The resulitng image uses the built-in Flask server and has additional debugging dependencies installed. 
To start a docker container run the following command:  
`docker run -p 8080:8080 tb17_apiexperiments_edrserver_python`
#### Debugging with Docker and Visual Studio Code
The repository includes a launch configuration (*.vscode/launch.json*) for the open-source IDE Visual Studio Code that can be used for debugging while running the application in a docker container.  
First start the application with Docker Compose:  
`docker-compose --profile debug up`.  
Second, simply start the debugger in Visual Studio Code (*Run -> Start Debugging*). After that it is possible to debug the application within Visual Studio Code (e.g. defining break points) as if it was running locally without Docker.
#### Configuration
The default backend configuration can be overridden by binding a local configuration file to the docker container. This can be done by adding a volume binding to the above Docker run command.  
`-v /path/to/backend_configuration.json:/usr/src/app/backend_configuration.json`  
The default configuration is equal to the example configuration file below.  

##### NetCDF Backend
The OGC API - EDRimplementation currently uses netCDF files as data backends. The data backends are defined in a configuration (JSON) file.  
- _type_ attribute must be "NETCDF" for netCDF backends
- in EDR each collection consists of multiple instances (which are again collections)
- for NetCDF backend each instance represents a netCDF file
  - every netCDF file must consist of a singe data array which has the dimensions _x_,_y_ and _time_.

The netCDF file that is configured in the example configuration (see below) is contained in the docker image and can be used as demo data. In order to add other data it is necessary to mount a data directory of the host system to the docker container.  
The _filepath_ parameter in the instance configuration (relative or absolute) always refers to the container (not to the host system).


  
**Example Backend Configuration**
<details>
<summary>backend_configuration.json</summary>
<p>

```json
{
	"server": {
		"title": "TB-17 Experiments API Python Server",
		"description": "TB-17 Experiments API Python Server"
	},
	"backends": [
		{
			"id": "example_netcdf_backend",
			"type": "NETCDF",
			"config": {
				"collections": {
					"netcdf_collection": {
						"title": "Sample NetCDF Collection",
						"description": "this is a sample NetCDF collection",
						"instances": {
							"instanceA": {
								"title": "Sample NetCDF Instance A",
								"description": "this is a sample instance of a sample NetCDF collection ",
								"bbox": [
									-180.0,
									-90.0,
									180.0,
									90.0
								],
								"timeinterval": [
									"2000-01-01",
									"2021-01-01"
								],
								"filePath": "./openapi_server/data/20191115T102219-20201214T101151_classification.nc"
							}
						}
					}
				}
			},
			"collections": [
				"netcdf_collection"
			]
		}
	]
}
```

</p>
</details>

### Data Queries
The EDR server implementation supports radius, position and area data queries.
#### radius query
- _/radius_ endpoint
- within: radius
- within_units: unit of the radius, either M (meter) or KM (kilometer)
- radius_coords: center of the circle (WKT Point geometry), WGS84)
- datetime: either a single datetime or a interval (_start/end_), use _.._ for open intervals (_../end_, _start/.._)
  
example:  
`http://localhost:8080/collections/netcdf_collection/instances/instanceA/radius?within=10&within-units=KM&radiusCoords=POINT(37.64830%20-1.65650)&datetime=2020-12-14%2000:00:00`
#### position query 
- _/position_ endpoint
- coords: coords of the position (WKT Point geometry), WGS84)
- datetime: see above

#### area query 
- _/area_ endpoint
- coords: coords of the area geometry(WKT Polygon geometry), WGS84)
- datetime: see above
